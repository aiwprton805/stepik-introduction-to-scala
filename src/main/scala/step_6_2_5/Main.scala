package step_6_2_5

/*
List - одна из любимых коллекций скалистов. Её иммутабельность играет на руку при написании параллельных программ, а её
API позволяет эффективно работать с элементами, лежащими в начале коллекции. С задачей добавления одиночных элементов в
начало она справится хорошо (за константное время), так как реализована на основе односвязного списка, но вот
ассимптотическая оценка операции добавления таких элементов в конец вырастет до O(n) , где n - длина списка (подробнее,
почему List реализован на односвявзных списках, и почему так происходит можно почитать тут
(https://stackoverflow.com/questions/1320139/why-is-appending-to-a-list-bad)).
И тут на сцену выходит структура данных под названием Difference List.
Рассмотрим две операции над списками: операцию .prepend добавления элементов в начало списка и операцию .append
добавления элементов в конец списка. Каждую такую операцию можно рассматривать как некоторую функцию List[A] => List[A],
где A - тип элементов списка, тогда некоторая цепочка таких операций - это композиция таких функций. Именно за счёт
такого приёма DiffList-ы позволяют избавиться от дорогостоящего добавления в конец, заменяя его на добавление в начало.
Поговорим подробнее, как это происходит.
Ваша реализация DiffListImp[A] должна реализовывать следующий интерфейс:

abstract class DiffList[A](calculate: List[A] => List[A]) {
  def prepend(s: List[A]): DiffList[A]

  def append(s: List[A]): DiffList[A]

  def result: List[A]
}

Вам необходимо реализовать prepend и append и result:
1. Метод prepend принимает на вход список s, добавляемый в начало. Вернуть надо новый объект, сконструировав его от
новой функции. Эта функция должна возвращать список s , добавленный в начало к списку, возвращаемому из calculate.
2. Метод append принимает на вход список s, добавляемый в конец. Вернуть надо новый объект, сконструировав его от новой
функции. Эта функция должна возвращать результат применения функции calculate к конкатенации списка  s и аргумента этой
функции.
3. Метод result применяет все накопленные операции и отдаёт итоговый список.

Как выглядит использование DiffListImpl:

val l1 = List(1,2,3)
val l2 = List(4,5,6)
val dl = new DiffListImpl[Int](identity)

val result = dl.append(l2).prepend(l1).result // List(1,2,3,4,5,6)

Ваша задача - реализовать недостающие методы интерфейса, ничего считывать из консоли и писать в неё не надо.
Справка: сконструировать новый объект можно так: ﻿

val f = identity[List[Int]]
val obj = new DiffListImpl(f)
*/

object Main extends App {
  val l1 = List(1, 2, 3)
  val l2 = List(4, 5, 6)
  val dl = new DiffListImpl[Int](identity)

  val result = dl.append(l2).prepend(l1).append(l1).prepend(l2).result
  println(result)
}
